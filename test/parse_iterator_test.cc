#include "gtest/gtest.h"
#include <functional>
#include <list>
#include "parse_iterator.h" 
//类内成员不能初始化？
const char file_data[432]{
	0x8C, 0x19, 0xFC, 0x33, 0x00, 0x37, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0xFF, 0x53, 0x48, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x00, 0xA2, 0x17, 0xFE,
		0x9A, 0xC8, 0xC3, 0xA5, 0xC9, 0xCF, 0xD6, 0xA4, 0xD6, 0xB8, 0xCA, 0xFD, 0x00, 0xB8, 0xFE, 0x76,
		0x80, 0x33, 0x9E, 0x53, 0x33, 0x6B, 0x01, 0x45, 0x1F, 0x75, 0x02, 0x45, 0x0A, 0x57, 0x01, 0x45,
		0xAE, 0x5F, 0x02, 0x45, 0x97, 0xFD, 0xB6, 0x4C, 0x99, 0xEC, 0x94, 0x51, 0x49, 0x02, 0x07, 0x01,
		0x00, 0x85, 0x9F, 0x53, 0xAE, 0x07, 0x02, 0x45, 0xAE, 0x07, 0x02, 0x45, 0xB8, 0x0A, 0x01, 0x45,
		0x33, 0x2B, 0x01, 0x45, 0x54, 0x77, 0xA7, 0x4C, 0xD9, 0x1A, 0x84, 0x51, 0xB2, 0x00, 0xD8, 0x02,
		0x80, 0xD6, 0xA0, 0x53, 0x14, 0x06, 0x01, 0x45, 0x8F, 0x2E, 0x01, 0x45, 0x00, 0x3C, 0x00, 0x45,
		0x52, 0x78, 0x00, 0x45, 0x45, 0x68, 0xA6, 0x4C, 0x1D, 0x44, 0x83, 0x51, 0xF3, 0x00, 0x7C, 0x02,
		0xFF, 0xFF, 0xFF, 0xFF, 0x53, 0x48, 0x36, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x3C, 0x00, 0x45,
		0x9A, 0xC8, 0xC3, 0xA5, 0xC6, 0xD6, 0xB7, 0xA2, 0xD2, 0xF8, 0xD0, 0xD0, 0x00, 0x00, 0x7C, 0x02,
		0x80, 0x33, 0x9E, 0x53, 0x14, 0xAE, 0x1B, 0x41, 0x85, 0xEB, 0x1D, 0x41, 0x3D, 0x0A, 0x1B, 0x41,
		0xC3, 0xF5, 0x1C, 0x41, 0x30, 0xA0, 0x90, 0x49, 0xFA, 0x3F, 0x8A, 0x4E, 0xC5, 0x00, 0x00, 0x00,
		0x00, 0x85, 0x9F, 0x53, 0xAE, 0x47, 0x1D, 0x41, 0xAE, 0x47, 0x1D, 0x41, 0x29, 0x5C, 0x1B, 0x41,
		0x14, 0xAE, 0x1B, 0x41, 0x30, 0xF1, 0x5E, 0x49, 0xA0, 0xD4, 0x54, 0x4E, 0xC5, 0x00, 0x00, 0x00,
		0x80, 0xD6, 0xA0, 0x53, 0x14, 0xAE, 0x1B, 0x41, 0xEC, 0x51, 0x1C, 0x41, 0x29, 0x5C, 0x1B, 0x41,
		0x14, 0xAE, 0x1B, 0x41, 0x80, 0x41, 0x22, 0x49, 0x7C, 0x5E, 0x1A, 0x4E, 0xC5, 0x00, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0xFF, 0x53, 0x5A, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x00, 0x5C, 0x1B, 0x41,
		0x9A, 0xC8, 0xC3, 0xA5, 0xCD, 0xF2, 0x20, 0x20, 0xBF, 0xC6, 0xA3, 0xC1, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x33, 0x9E, 0x53, 0x5C, 0x8F, 0x06, 0x41, 0x52, 0xB8, 0x06, 0x41, 0x48, 0xE1, 0x02, 0x41,
		0xF6, 0x28, 0x04, 0x41, 0x90, 0xD1, 0x52, 0x49, 0xBB, 0x1E, 0x2A, 0x4E, 0xC5, 0x00, 0xA3, 0x5D,
		0x00, 0x85, 0x9F, 0x53, 0x00, 0x00, 0x04, 0x41, 0x00, 0x00, 0x04, 0x41, 0xD7, 0xA3, 0x00, 0x41,
		0x85, 0xEB, 0x01, 0x41, 0x20, 0x7A, 0x27, 0x49, 0xFC, 0x4D, 0x04, 0x4E, 0xC5, 0x00, 0x59, 0x50,
		0x80, 0xD6, 0xA0, 0x53, 0x85, 0xEB, 0x01, 0x41, 0x52, 0xB8, 0x02, 0x41, 0xB8, 0x1E, 0x01, 0x41,
		0x9A, 0x99, 0x01, 0x41, 0xA0, 0x1F, 0xA9, 0x48, 0xBB, 0x3A, 0x86, 0x4D, 0xC5, 0x00, 0xAF, 0x30,
		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//如果要为一组测试(testSuit为blockTest)提供初始化和清理方法，则要定义该testSuit
class ParseIterator : public testing::Test {
protected:
	//testSuit的初始化函数
	static void SetUpTestCase() {

	}

	//testSuit的清理函数
	static void TearDownTestCase() {
	};
	//SetUpTestCase() 方法在第一个TestCase之前执行
	//TearDownTestCase() 方法在最后一个TestCase之后执行
	//SetUp()方法在每个TestCase之前执行
	//TearDown()方法在每个TestCase之后执行

	//在TestSuit的各测试案例中共享的一些资源，定义为static


};
int intArray[5]{1, 2, 3, 4, 5};
char *int_ptr = reinterpret_cast<char*>(intArray);


/*
stl规范中，input迭代器必须具备的能力：
1.Is copy-constructible, copy-assignable and destructible
x b(a);b=a
必须实现拷贝构造函数，需有析构函数
2.Can be compared for equivalence using the equality/inequality operators
(meaningful if both iterators are be in domain).
a == b;a != b
必须重载==和!=操作符
3.Can be dereferenced as an rvalue (if in a dereferenceable state).
*a;a->m
重载*和->操作符
4.Can be incremented (if in a dereferenceable state).
The result is either also dereferenceable or a past-the-end iterator.
The previous iterator value is not required to be dereferenceable after the increase.
++a
(void)a++
*a++
要重载前置和后置的++操作符
5.Its value type does not need to be assignable
t = u not required
它的value type不需要assignable，不需要不代表不许可。
6.c++ 11 only
Lvalues are swappable.
swap(a,b)
提供swap函数
*/

//默认构造函数，由编译器生成，不用实现代码
TEST_F(ParseIterator, construct_default)
{
	parse_iterator<int *, char *> iter;
}

//主要构造函数，传入两个迭代器和一个T类型的move
TEST_F(ParseIterator, construct_regular)
{
	//默认构造函数，由编译器生成，不用实现代码
	parse_iterator<int *, char *> iter(int_ptr,int_ptr+sizeof(int)*5,(int *)int_ptr );
}
//拷贝构造函数
TEST_F(ParseIterator, construct_copy)
{
	parse_iterator<int *, char *> iter(int_ptr, int_ptr + sizeof(int)* 5, (int *)int_ptr);
	parse_iterator<int *, char *> iter_copy(iter);
	parse_iterator<int *, char *> iter_assign=iter;
	EXPECT_EQ(iter,iter_copy);
	EXPECT_EQ(iter, iter_assign);
}


//operator==
TEST_F(ParseIterator, operator_equal)
{
	//两个nullptr比较，应相等
	parse_iterator<int *, char *> iter;
	parse_iterator<int *, char *> empty_iter;
	EXPECT_EQ(iter, empty_iter);

	//两个相等的iterator
	parse_iterator<int *, char *> iter1(int_ptr, int_ptr + sizeof(int)* 5, (int *)int_ptr);
	parse_iterator<int *, char *> iter2(int_ptr, int_ptr + sizeof(int)* 5, (int *)int_ptr);
	EXPECT_EQ(true, iter1 == iter2);

	//不相等的两个迭代器
	parse_iterator<int *, char *> iter3(int_ptr, int_ptr + sizeof(int)* 5, (int *)(int_ptr + sizeof(int)));
	EXPECT_EQ(false, iter1 == iter3);

	//与默认构造的迭代器比较
	EXPECT_EQ(false, iter == iter3);
}

//operator!=
TEST_F(ParseIterator, operator_equal_not)
{
	//两个nullptr比较，应相等
	parse_iterator<int *, char *> iter;
	parse_iterator<int *, char *> empty_iter;
	EXPECT_EQ(iter, empty_iter);

	//两个相等的iterator
	parse_iterator<int *, char *> iter1(int_ptr, int_ptr + sizeof(int)* 5, (int *)int_ptr);
	parse_iterator<int *, char *> iter2(int_ptr, int_ptr + sizeof(int)* 5, (int *)int_ptr);
	EXPECT_EQ(false, iter1 != iter2);

	//不相等的两个迭代器
	parse_iterator<int *, char *> iter3(int_ptr, int_ptr + sizeof(int)* 5, (int *)(int_ptr + sizeof(int)));
	EXPECT_EQ(true, iter1 != iter3);

	//与默认构造的迭代器比较
	EXPECT_EQ(true, iter != iter3);
}



